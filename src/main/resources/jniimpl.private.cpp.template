/*
 * Copyright (C) 2016 Matej Hrazdira.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

$$$ BGN $$$
#include "jniimpl.private.h"

#include "corbabinding.h"
#include "corbabindinglib.h"

#include <map>
#include <string>

using namespace corbabinding;

namespace corbabinding {
class TypeCache {
public:
	typedef jobject (* convertAnyImpl)(JNIEnv * env, const CORBA::Any & in);
	TypeCache();
	virtual ~TypeCache();
	jobject convert(JNIEnv * env, const char * name, CORBA::Object_ptr in);
	convertAnyImpl getAnyConversion(const char * name);

	static jobject convertAnyNoOp(JNIEnv * env, const CORBA::Any & any) {
		return nullptr;
	}

private:
	typedef jobject (* convertImpl)(JNIEnv * env, CORBA::Object_ptr in);
	std::map<std::string, convertImpl> $$$TYPE_CACHE_INTERFACE_TABLE$$$;

	template<typename T> static jobject $$$TYPE_CACHE_CONVERT_OBJ$$$(JNIEnv * env, CORBA::Object_ptr obj) {
		if (obj) {
			return ::corbabinding::convert(env, T::_narrow(obj));
		} else {
			return nullptr;
		}
	}

	std::map<std::string, convertAnyImpl> $$$TYPE_CACHE_ANY_TABLE$$$;

	template<typename T> static jobject $$$TYPE_CACHE_CONVERT_ANY$$$(JNIEnv * env, const CORBA::Any & any) {
		T * ptr;
		if ((any >>= ptr)) {
			return ::corbabinding::convert(env, ptr);
		} else {
			return nullptr;
		}
	}
};

TypeCache::TypeCache() {
$$$ TYPE CACHE ENTRIES $$$
}

TypeCache::~TypeCache() {

}

jobject TypeCache::convert(JNIEnv* env, const char * name, CORBA::Object_ptr in) {
	auto item = $$$TYPE_CACHE_INTERFACE_TABLE$$$.find(name);
	if (item != $$$TYPE_CACHE_INTERFACE_TABLE$$$.end()) {
		return item->second(env, in);
	} else {
		return nullptr;
	}
}

TypeCache::convertAnyImpl TypeCache::getAnyConversion(const char * name) {
	auto item = $$$TYPE_CACHE_ANY_TABLE$$$.find(name);
	if (item != $$$TYPE_CACHE_ANY_TABLE$$$.end()) {
		return item->second;
	} else {
		return convertAnyNoOp;
	}
}

class EventConsumer : public AnyEventConsumer {
public:
	EventConsumer(
			JNIEnv * env,
			jobject jconsumer,
			TypeCache * typeCache,
			CORBA::ULong type,
			const char * typeName)
		: AnyEventConsumer(type) {
		mConversionImpl = typeCache->getAnyConversion(typeName);
		mConsumer = env->NewGlobalRef(jconsumer);
		env->GetJavaVM(&mJvm);
		mJniVersion = env->GetVersion();
	}

	void onAnyEvent(const CORBA::Any & any) {
		JNIEnv * env = attach();
		if (!env) {
			return;
		}
		jobject callbackData = mConversionImpl(env, any);
		env->CallVoidMethod(mConsumer, $$$JNI$$$->$$$CACHE_IMPL$$$._event_consumer_._callback_, callbackData);
		env->DeleteLocalRef(callbackData);
	}

	virtual ~EventConsumer() {
		JNIEnv * env = attach();
		env->DeleteGlobalRef(mConsumer);
	}

private:
	JavaVM * mJvm;
	jint mJniVersion;
	TypeCache::convertAnyImpl mConversionImpl;
	jobject mConsumer;

	JNIEnv * attach() {
		JNIEnv * env = nullptr;
		mJvm->GetEnv(reinterpret_cast<void**>(&env), mJniVersion);
		if (env) {
			return env;
		} else {
			JavaVMAttachArgs threadParams;
			threadParams.version = mJniVersion;
			threadParams.name = (char *) "EvnetConsumer thread (native)";
			threadParams.group = 0x0;
			jint res = mJvm->AttachCurrentThread((void **) &env, &threadParams);
			return env;
		}
	}
};

} /* namespace corbabinding */

static TypeCache * sTypeCache = nullptr;

jint JNI_OnLoad(JavaVM* vm, void* reserved) {
	JNIEnv* env;
	if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
		return -1;
	}

	init(env);
	sTypeCache = new TypeCache();

	return JNI_VERSION_1_6;
}

static char * getStringChars(JNIEnv * env, jstring jstr) {
	const char * str = env->GetStringUTFChars(jstr, nullptr);
	char * result = CORBA::string_dup(str);
	env->ReleaseStringUTFChars(jstr, str);
	return result;
}

JNIEXPORT jlong JNICALL $$$CORBA_PROVIDER_JNI_SIG$$$_init(JNIEnv * env, jobject thiz, jobjectArray jorbArgs, jstring jeventServiceName) {

	char * eventServiceName = getStringChars(env, jeventServiceName);

	jsize jorbArgCount = env->GetArrayLength(jorbArgs);
	int orbArgCount = jorbArgCount + 2;

	char ** orbArgs = new char *[orbArgCount];

	orbArgs[0] = CORBA::string_dup("UNUSED");
	for (int i = 0; i < jorbArgCount; i++) {
		jstring jarg = (jstring) env->GetObjectArrayElement(jorbArgs, i);
		orbArgs[i + 1] = getStringChars(env, jarg);
		env->DeleteLocalRef(jarg);
	}
	orbArgs[orbArgCount - 1] = CORBA::string_dup("");

	jthrowable pendingException = nullptr;
	NativeWrapper * result = nullptr;
	try {
		result = new NativeWrapper(orbArgCount, orbArgs, eventServiceName);
	} catch (const CORBA::Exception & e) {
		pendingException = convert(env, e);
	}

	CORBA::string_free(eventServiceName);
	for (int i = 0; i < orbArgCount; i++) {
		CORBA::string_free(orbArgs[i]);
	}

	if (pendingException != nullptr) {
		env->Throw(pendingException);
	}

	return (jlong) result;
}

JNIEXPORT jobject JNICALL $$$CORBA_PROVIDER_JNI_SIG$$$_resolveImpl(JNIEnv * env, jobject thiz, jlong jnativeWrapper, jstring jclassName, jstring jcorbaName) {
	try {
		CORBA::String_var className = getStringChars(env, jclassName);
		CORBA::String_var corbaName = getStringChars(env, jcorbaName);
		NativeWrapper * nativeWrapper = (NativeWrapper *) jnativeWrapper;
		CORBA::Object_var obj = nativeWrapper->resolveName(corbaName);
		return sTypeCache->convert(env, className, obj);
	} catch (const CORBA::Exception & e) {
		env->Throw(convert(env, e));
		return (jobject) 0x0;
	}
}

JNIEXPORT void JNICALL $$$CORBA_PROVIDER_JNI_SIG$$$_disposeImpl(JNIEnv * env, jobject thiz, jlong nativeWrapper) {
	delete (NativeWrapper *) nativeWrapper;
}

JNIEXPORT jlong JNICALL $$$EVENT_CONSUMER_JNI_SIG$$$_connectConsumer(JNIEnv * env, jobject thiz, jlong jnativeWrapper, jint subscription, jstring eventClass) {
	NativeWrapper * nativeWrapper = ((NativeWrapper *) jnativeWrapper);
	CORBA::String_var className = getStringChars(env, eventClass);
	EventConsumer * eventConsumer = new EventConsumer(env, thiz, sTypeCache, subscription, className.in());
	try {
		eventConsumer->connect(nativeWrapper);
	} catch (const CORBA::Exception & e) {
		env->Throw(convert(env, e));
		delete eventConsumer;
		eventConsumer = 0x0;
	}
	return (jlong) eventConsumer;
}

JNIEXPORT void JNICALL $$$EVENT_CONSUMER_JNI_SIG$$$_disposeImpl(JNIEnv * env, jobject thiz, jlong nativeWrapper) {
	EventConsumer * consumer = (EventConsumer *) nativeWrapper;
	try {
		consumer->disconnect();
	} catch (const CORBA::Exception & e) {
		// ignore
	}
	delete consumer;
}
